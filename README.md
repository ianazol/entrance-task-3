# Задание 3

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать, 
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл. 
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.

## Решение

**Проблема "Разложить файлы красиво".** Вероятно, что `service-worker.js` был перенесен из корня в папку `./assets`. Сервис-воркер обрабатывает только те запросы, которые входят в его scope и максимальная видимость scope соответствует его расположению. Таким образом, сервис-воркер приложения Гифки получил scope `/assets` и потому перестал обрабатывать запрос на `./gifs.html` и файлы в `./vendor/`   
**Решение:** перенести `service-worker.js` в корень и, таким образом, расширить область видимости до всего приложения.

Перехожу в режим оффлайн (Chrome Dev Tools -> Network), обновляю страницу и вижу, что страница `gifs.html` по-прежнему недоступна, но файлы из `vendor` и `assets` попали кеш.

**Проблема «Более надёжное кеширование на этапе fetch».** Смотрим, что происходит в обработчике события `fetch`: кешируются запросы, урл которых содержит `vendor/`, `assets/` или заканчивается на `jquery.min.js`. В остальных случаях, запрос отправляется в сеть, и если он завершился неуспешно (например, когда приложение находится в оффлайне), то происходит попытка получения из кеша. Но HTML-страница не попадает в кеш ни на одном этапе работы сервис-воркера.   
**Решение.**

1. Можно добавить в `needStoreForOffline` условие `cacheKey.endsWith('gifs.html')`, но тогда эта страница, как и остальные, всегда будут тянуться из кеша, даже в онлайне.
2. Можно закешировать файл `gifs.html` на стадии установки сервис-воркера.

```javascript
self.addEventListener('install', event => {
  const promise = preCacheAllFavorites()
  .then(() => preCacheStatic())
  ...
});

function preCacheStatic() {
  return caches.open(CACHE_VERSION).then(function (cache) {
      return cache.add('gifs.html');
  });
}
```
В этом случае в онлайне мы всегда будем получать актуальный `gifs.html`, однако в оффлайне будет оставаться первая закешированная версия.

3. Реализовать стратегию: получить из сети, поместить в кеш, если запрос был отменен - взять из кеша. Этот вариант считаю наиболее оптимальным, реализовала его.

## Ответы на вопросы
1-2. `self.skipWaiting()` и `self.clients.claim()`
Используются вместе, чтобы ускорить обновление сервис-воркера. В обычном режиме, обновленный сервис воркер регистрируется, но не активируется до тех пор, пока есть открытые страницы, использующие старый сервис-воркер.   
`self.skipWaiting()` говорит сервис-воркеру, что надо немедленно стать активным, вызывая события `onactivate`   
`self.clients.claim()` позволяет новому сервис-воркеру перехватить управление всех страниц (в том числе и открытых)

3. Не покрывает случаи, когда урл запроса имеет параметры.   
Например, для запросов:   
https://api.giphy.com/v1/gifs/search?limit=10&lang=ru&q=cats&api_key=dc6zaTOxFJmzC   
https://api.giphy.com/v1/gifs/search?limit=10&lang=ru&q=dogs&api_key=dc6zaTOxFJmzC   
ключ будет одинаковым - https://api.giphy.com/v1/gifs/search, второй запрос перезапишет кеш первого
4. Для того, чтобы удалить весь кеш, исключая тот, ключ которого совпадает с текущим (CACHE_VERSION)
5. Потоки запроса и ответа могут быть прочитаны только один раз.   
`response.clone()` позволяет создать клон ответа. Таким образом, в кеш будет записан клон, а в браузер отправится оригинальный ответ.

## Дополнительное задание.
Добавляю статику в кеш на этапе установки сервис-воркера.